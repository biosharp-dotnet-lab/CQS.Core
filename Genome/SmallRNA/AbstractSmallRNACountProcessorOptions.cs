using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using RCPA.Commandline;
using CommandLine;
using System.IO;
using CQS.Genome.Sam;
using CQS.Genome.Gtf;
using RCPA.Seq;
using CQS.Genome.Feature;
using CQS.Genome.Mapping;
using CQS.Genome.Gsnap;
using CQS.Genome.Mirna;

namespace CQS.Genome.SmallRNA
{
  public abstract class AbstractSmallRNACountProcessorOptions : AbstractCountProcessorOptions
  {
    public const double DEFAULT_MinimumOverlapPercentage = 0.5;
    public const int DEFAULT_MaxMismatchForLincRNA = 0;
    public const int DEFAULT_MinReadLengthForLincRNA = 20;

    public static readonly long[] DEFAULT_Offsets = new long[] { 0, 1, 2 };

    public AbstractSmallRNACountProcessorOptions()
    {
      this.MinimumOverlapPercentage = DEFAULT_MinimumOverlapPercentage;
      this.MaximumMismatchForLincRNA = DEFAULT_MaxMismatchForLincRNA;
      this.MinimumReadLengthForLincRNA = DEFAULT_MinReadLengthForLincRNA;
      this.MaximumNoPenaltyMutationCount = DEFAULT_MaximumNoPenaltyMutationCount;
      this.Offsets = DEFAULT_Offsets.ToList();
    }

    [OptionList('i', "inputFile", Required = true, MetaValue = "FILE", Separator = ',', HelpText = "Alignment sam/bam files")]
    public virtual IList<string> InputFiles { get; set; }

    [Option('g', "coordinateFile", Required = true, MetaValue = "FILE", HelpText = "Genome annotation coordinate file generated by smallrna_database function of cqstools in bed format")]
    public string CoordinateFile { get; set; }

    [Option('f', "coordinateFastaFile", Required = false, MetaValue = "FILE", HelpText = "Genome annotation coordinate fasta file")]
    public string FastaFile { get; set; }

    [Option('q', "fastqFile", Required = false, MetaValue = "FILE", HelpText = "Original fastq file")]
    public string FastqFile { get; set; }

    [OptionList("offsets", Required = false, Separator = ',', HelpText = "Allowed (prilority ordered) offsets from miRNA locus, default: 0,1,2")]
    public List<long> Offsets { get; set; }

    [Option("min_overlap", DefaultValue = DEFAULT_MinimumOverlapPercentage, HelpText = "Minimum overlap percentage between region and read (0.0 indicates at least 1 base overlap)")]
    public double MinimumOverlapPercentage { get; set; }

    [Option("max_linc_mismatch", DefaultValue = DEFAULT_MaxMismatchForLincRNA, HelpText = "Maximum mismatch allowed for read mapped to lincRNA")]
    public int MaximumMismatchForLincRNA { get; set; }

    [Option("min_linc_read_length", DefaultValue = DEFAULT_MinReadLengthForLincRNA, HelpText = "Minimum sequence length allowed for read mapped to lincRNA")]
    public int MinimumReadLengthForLincRNA { get; set; }

    [Option("not_overwrite", DefaultValue = false, HelpText = "Don't overwrite existing result files")]
    public bool NotOverwrite { get; set; }

    public override bool PrepareOptions()
    {
      var result = base.PrepareOptions();

      foreach (var file in this.InputFiles)
      {
        if (!File.Exists(file))
        {
          ParsingErrors.Add(string.Format("Input file not exists {0}.", file));
        }
      }

      if (!File.Exists(this.CoordinateFile))
      {
        ParsingErrors.Add(string.Format("Coordinate file not exists {0}.", this.CoordinateFile));
      }

      if (!string.IsNullOrEmpty(this.FastaFile) && !File.Exists(this.FastaFile))
      {
        ParsingErrors.Add(string.Format("Fasta file not exists {0}.", this.FastaFile));
      }

      if (!string.IsNullOrEmpty(this.FastqFile) && !File.Exists(this.FastqFile))
      {
        ParsingErrors.Add(string.Format("Fastq file not exists {0}.", this.FastqFile));
      }

      if (this.Offsets == null || this.Offsets.Count == 0)
      {
        this.Offsets = DEFAULT_Offsets.ToList();
      }

      return result && ParsingErrors.Count == 0;
    }

    private SmallRNACountMap cm;

    public override SmallRNACountMap GetCountMap()
    {
      if (cm == null)
      {
        cm = new SmallRNACountMap(this.CountFile);
        var keys = cm.Counts.Keys.Where(m => m.Contains(SmallRNAConsts.NTA_TAG)).ToArray();
        foreach (var key in keys)
        {
          var purekey = key.StringBefore(SmallRNAConsts.NTA_TAG);
          cm.Counts[purekey] = cm.Counts[key];
        }
      }
      return cm;
    }

    public virtual List<FeatureLocation> GetSequenceRegions()
    {
      //Read sequence regions
      var items = SequenceRegionUtils.GetSequenceRegions(CoordinateFile);
      items.ForEach(m =>
      {
        m.Seqname = m.Seqname.StringAfter("chr");
      });

      //Fill sequence information, only miRNA and tRNA will be filled.
      if (!string.IsNullOrEmpty(this.FastaFile))
      {
        Console.WriteLine("Reading sequence from {0} ...", this.FastaFile);
        var seqs = SequenceUtils.Read(new FastaFormat(), this.FastaFile).ToDictionary(m => m.Name);
        items.ForEach(m =>
        {
          if (m.Name.StartsWith(SmallRNAConsts.miRNA) || m.Name.StartsWith(SmallRNAConsts.tRNA))
          {
            if (seqs.ContainsKey(m.Name))
            {
              m.Sequence = seqs[m.Name].SeqString;
            }
            else
            {
              Console.WriteLine("Missing sequence: " + m.Name);
            }
          }
          else
          {
            m.Sequence = string.Empty;
          }
        });
        seqs.Clear();
      }

      var result = items.ConvertAll(m => new FeatureLocation(m)).ToList();
      result.ForEach(m => m.Category = m.Name.StringBefore(":"));
      return result;
    }
  }
}
